(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=t(r);fetch(r.href,s)}})();async function p(){if(!navigator.gpu)throw new Error("WebGPU not supported on this browser.");const e=await(await navigator.gpu.requestAdapter({powerPreference:"high-performance"})).requestDevice({requiredLimits:{maxComputeWorkgroupStorageSize:16384,maxStorageBufferBindingSize:134217728}});return console.log("WebGPU initialized successfully"),e}async function b(a,e,t){const i=new Float32Array(t).fill(1),r=new Float32Array(t).fill(0),s=new Float32Array(t*2).fill(0),o=new ArrayBuffer(16),n=new DataView(o);let l=0;n.setUint32(l,e,!0),l+=4,n.setUint32(l,e,!0),l+=4,n.setFloat32(l,Math.sqrt(2),!0),l+=4,n.setFloat32(l,1/Math.sqrt(2),!0);const f=a.createBuffer({label:"Uniform Buffer",size:o.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),d=a.createBuffer({label:"Grid Buffer",size:i.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),u=a.createBuffer({label:"Distance Buffer (Ping)",size:r.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),c=a.createBuffer({label:"Distance Buffer (Pong)",size:r.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),g=a.createBuffer({label:"Flowfield Buffer",size:s.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});return a.queue.writeBuffer(f,0,o),a.queue.writeBuffer(d,0,i),a.queue.writeBuffer(u,0,r),a.queue.writeBuffer(c,0,r),a.queue.writeBuffer(g,0,s),{uniformBuffer:f,gridBuffer:d,distanceBufferPing:u,distanceBufferPong:c,flowfieldBuffer:g}}const B="/BFS-Flowfield-webgpu/src/shaders/BFS.wgsl",m="/BFS-Flowfield-webgpu/src/shaders/BFSNoRelaxation.wgsl",w="/BFS-Flowfield-webgpu/src/shaders/distanceGrid.wgsl",y="/BFS-Flowfield-webgpu/src/shaders/flowfield.wgsl",P="/BFS-Flowfield-webgpu/src/shaders/gradient.wgsl",S="/BFS-Flowfield-webgpu/src/shaders/obstacleGrid.wgsl";async function h(){const a=["BFS","BFSNoRelaxation","gradient","obstacleGrid","distanceGrid","flowfield"],e=i=>new URL(Object.assign({"../shaders/BFS.wgsl":B,"../shaders/BFSNoRelaxation.wgsl":m,"../shaders/distanceGrid.wgsl":w,"../shaders/flowfield.wgsl":y,"../shaders/gradient.wgsl":P,"../shaders/obstacleGrid.wgsl":S})[`../shaders/${i}.wgsl`],import.meta.url).href,t={};return await Promise.all(a.map(async i=>{try{const r=await fetch(e(i));if(!r.ok)throw new Error(`Failed to load shader ${i}: ${r.status}`);t[i]=await r.text();const s=t[i].includes("fn main("),o=t[i].includes("fn vs("),n=t[i].includes("fn fs(");!s&&!o&&!n&&console.warn(`Warning: Shader ${i} might be missing entry points (main/vs/fs)`)}catch(r){console.error(`Error loading shader ${i}:`,r)}})),t}async function v(a){const e=await h(),t=a.createShaderModule({label:"BFS Shader",code:e.BFS}),i=a.createShaderModule({label:"BFS No Relaxation Shader",code:e.BFSNoRelaxation}),r=a.createShaderModule({label:"Gradient Shader",code:e.gradient}),s=a.createBindGroupLayout({label:"BFS Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),o=a.createBindGroupLayout({label:"Gradient Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),n=a.createPipelineLayout({label:"BFS Pipeline Layout",bindGroupLayouts:[s]}),l=a.createPipelineLayout({label:"Gradient Pipeline Layout",bindGroupLayouts:[o]}),f=a.createComputePipeline({label:"BFS Pipeline",layout:n,compute:{module:t,entryPoint:"main"}}),d=a.createComputePipeline({label:"BFS No Relaxation Pipeline",layout:n,compute:{module:i,entryPoint:"main"}}),u=a.createComputePipeline({label:"Gradient Pipeline",layout:l,compute:{module:r,entryPoint:"main"}}),c={bfs:{pipeline:f,bindGroupLayout:s,layout:n},bfsNoRelaxation:{pipeline:d,bindGroupLayout:s,layout:n},gradient:{pipeline:u,bindGroupLayout:o,layout:l}};return console.log("Pipelines initialized successfully"),c}async function G(a,e,t){const i=a.createBindGroup({label:"BFS Bind Group (Ping)",layout:t.bfs.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.gridBuffer}},{binding:1,resource:{buffer:e.distanceBufferPing}},{binding:2,resource:{buffer:e.distanceBufferPong}},{binding:3,resource:{buffer:e.uniformBuffer}}]}),r=a.createBindGroup({label:"BFS Bind Group (Pong)",layout:t.bfs.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.gridBuffer}},{binding:1,resource:{buffer:e.distanceBufferPong}},{binding:2,resource:{buffer:e.distanceBufferPing}},{binding:3,resource:{buffer:e.uniformBuffer}}]}),s=a.createBindGroup({label:"Gradient Bind Group",layout:t.gradient.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.gridBuffer}},{binding:1,resource:{buffer:e.distanceBufferPing}},{binding:2,resource:{buffer:e.flowfieldBuffer}},{binding:3,resource:{buffer:e.uniformBuffer}}]});return{bfsPing:i,bfsPong:r,gradient:s,getGradientBindGroup:n=>{const l=n?e.distanceBufferPong:e.distanceBufferPing;return a.createBindGroup({label:"Dynamic Gradient Bind Group",layout:t.gradient.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.gridBuffer}},{binding:1,resource:{buffer:l}},{binding:2,resource:{buffer:e.flowfieldBuffer}},{binding:3,resource:{buffer:e.uniformBuffer}}]})}}}async function x(a){try{const i=(await(await fetch(a)).text()).trim().split(`
`),r=new Float32Array(32*32);for(let s=0;s<32;s++){const o=i[s].split(",");for(let n=0;n<32;n++)r[s*32+n]=parseFloat(o[n])}return r}catch(e){throw console.error("Error loading or parsing CSV:",e),e}}class C{constructor(e,t,i=32){this.device=e,this.canvas=t,this.context=t.getContext("webgpu"),this.gridSize=i,this.numberOfCells=i*i;const r=navigator.gpu.getPreferredCanvasFormat();this.context.configure({device:this.device,format:r}),this.presentationFormat=r,this.pipeline=null,this.bindGroup=null,this.positionBuffer=null,this.uvBuffer=null,this.indexBuffer=null,this.instanceBuffer=null,this.uniformBuffer=null,this.gridDataBuffer=null,this.currentSourcePos=null,this.updateCellCallback=null,this.isDragging=!1,this.initPromise=this.initialize()}async initialize(){await this.createShaderPipeline(),this.createQuadBuffers(),this.createUniformBuffer(),this.setupInteraction(),console.log("ObstacleGridRenderer initialized")}async createShaderPipeline(){const t=(await h()).obstacleGrid;if(!t)throw new Error("Failed to load obstacleGrid shader");const i=this.device.createShaderModule({label:"Obstacle Grid Shader",code:t});this.pipeline=this.device.createRenderPipeline({label:"Obstacle Grid Pipeline",layout:"auto",vertex:{module:i,entryPoint:"vs",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:8,attributes:[{shaderLocation:1,offset:0,format:"float32x2"}]},{arrayStride:8,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"uint32"},{shaderLocation:3,offset:4,format:"uint32"}]}]},fragment:{module:i,entryPoint:"fs",targets:[{format:this.presentationFormat}]}})}createQuadBuffers(){const e=new Float32Array([0,0,1,0,0,1,1,1]);this.positionBuffer=this.device.createBuffer({label:"Grid quad positions",size:e.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.positionBuffer.getMappedRange()).set(e),this.positionBuffer.unmap();const t=new Float32Array([0,0,1,0,0,1,1,1]);this.uvBuffer=this.device.createBuffer({label:"Grid quad UVs",size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.uvBuffer.getMappedRange()).set(t),this.uvBuffer.unmap();const i=new Uint16Array([0,1,2,2,1,3]);this.indexBuffer=this.device.createBuffer({label:"Grid quad indices",size:i.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint16Array(this.indexBuffer.getMappedRange()).set(i),this.indexBuffer.unmap(),this.createGridInstanceData()}createGridInstanceData(){const e=this.numberOfCells,t=new Uint32Array(e*2);let i=0;for(let r=0;r<this.gridSize;r++)for(let s=0;s<this.gridSize;s++)t[i++]=s,t[i++]=r;this.instanceBuffer=this.device.createBuffer({label:"Grid instance data",size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Uint32Array(this.instanceBuffer.getMappedRange()).set(t),this.instanceBuffer.unmap()}createUniformBuffer(){const e=new Float32Array([this.gridSize,this.gridSize,this.canvas.width,this.canvas.height,this.gridSize/2,this.gridSize/2]);this.uniformBuffer=this.device.createBuffer({label:"Grid uniform buffer",size:e.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.uniformBuffer.getMappedRange()).set(e),this.uniformBuffer.unmap()}async setGridDataBuffer(e){await this.initPromise,this.gridDataBuffer=e,this.createBindGroup()}createBindGroup(){if(!this.gridDataBuffer){console.warn("Grid data buffer not set yet");return}if(!this.pipeline){console.warn("Pipeline not ready yet");return}this.bindGroup=this.device.createBindGroup({label:"Obstacle Grid Bind Group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.gridDataBuffer}}]})}setupInteraction(){const e=t=>{const i=this.canvas.getBoundingClientRect(),r=t.clientX-i.left,s=t.clientY-i.top,o=Math.floor(r/i.width*this.gridSize),n=this.gridSize-1-Math.floor(s/i.height*this.gridSize);return o>=0&&o<this.gridSize&&n>=0&&n<this.gridSize?{x:o,y:n}:null};this.canvas.addEventListener("click",t=>{const i=e(t);if(!i||!this.updateCellCallback)return;const r=document.getElementById("drawingMode"),s=r?r.value:"traversable";if(s==="source")this.handleSourcePlacement(i.x,i.y);else{let o;switch(s){case"obstacle":o=0;break;case"difficult":o=.3;break;default:o=1;break}this.updateCellCallback(i.x,i.y,o)}}),this.canvas.addEventListener("mousedown",t=>{const i=document.getElementById("drawingMode"),r=i?i.value:"traversable";if(r!=="source"){this.isDragging=!0;const s=e(t);if(s&&this.updateCellCallback){let o;switch(r){case"obstacle":o=0;break;case"difficult":o=.3;break;default:o=1;break}this.updateCellCallback(s.x,s.y,o)}}}),this.canvas.addEventListener("mousemove",t=>{if(!this.isDragging||!this.updateCellCallback)return;const i=e(t);if(!i)return;const r=document.getElementById("drawingMode"),s=r?r.value:"traversable";let o;switch(s){case"obstacle":o=0;break;case"difficult":o=.3;break;default:o=1;break}this.updateCellCallback(i.x,i.y,o)}),document.addEventListener("mouseup",()=>{this.isDragging=!1})}updateGoalPosition(e,t){const i=new Float32Array([this.gridSize,this.gridSize,this.canvas.width,this.canvas.height,e,t]);this.device.queue.writeBuffer(this.uniformBuffer,0,i)}handleSourcePlacement(e,t){this.currentSourcePos={x:e,y:t},this.updateGoalPosition(e,t),this.updateCellCallback&&this.updateCellCallback(e,t,3)}async render(){if(await this.initPromise,!this.bindGroup){console.warn("Bind group not ready for rendering");return}const e={label:"Obstacle Grid Render Pass",colorAttachments:[{view:this.context.getCurrentTexture().createView(),clearValue:[.1,.1,.1,1],loadOp:"clear",storeOp:"store"}]},t=this.device.createCommandEncoder({label:"Obstacle Grid Encoder"}),i=t.beginRenderPass(e);i.setPipeline(this.pipeline),i.setBindGroup(0,this.bindGroup),i.setVertexBuffer(0,this.positionBuffer),i.setVertexBuffer(1,this.uvBuffer),i.setVertexBuffer(2,this.instanceBuffer),i.setIndexBuffer(this.indexBuffer,"uint16"),i.drawIndexed(6,this.numberOfCells,0,0,0),i.end(),this.device.queue.submit([t.finish()])}getCurrentSourcePos(){return this.currentSourcePos}initializeSource(e){for(let t=0;t<this.gridSize;t++)for(let i=0;i<this.gridSize;i++){const r=t*this.gridSize+i;if(e[r]===3){this.currentSourcePos={x:i,y:t};return}}this.currentSourcePos=null}setUpdateCellCallback(e){this.updateCellCallback=e}}class R{constructor(e,t,i=32){this.device=e,this.canvas=t,this.context=t.getContext("webgpu"),this.gridSize=i,this.numberOfCells=i*i;const r=navigator.gpu.getPreferredCanvasFormat();this.context.configure({device:this.device,format:r}),this.presentationFormat=r,this.pipeline=null,this.bindGroup=null,this.positionBuffer=null,this.uvBuffer=null,this.indexBuffer=null,this.instanceBuffer=null,this.uniformBuffer=null,this.distanceDataBuffer=null,this.initPromise=this.initialize()}async initialize(){await this.createShaderPipeline(),this.createQuadBuffers(),this.createUniformBuffer(),console.log("DistanceFieldRenderer initialized")}async createShaderPipeline(){const t=(await h()).distanceGrid;if(!t)throw new Error("Failed to load distanceGrid shader");const i=this.device.createShaderModule({label:"Distance Field Shader",code:t});this.pipeline=this.device.createRenderPipeline({label:"Distance Field Pipeline",layout:"auto",vertex:{module:i,entryPoint:"vs",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:8,attributes:[{shaderLocation:1,offset:0,format:"float32x2"}]},{arrayStride:8,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"uint32"},{shaderLocation:3,offset:4,format:"uint32"}]}]},fragment:{module:i,entryPoint:"fs",targets:[{format:this.presentationFormat}]}})}createQuadBuffers(){const e=new Float32Array([0,0,1,0,0,1,1,1]);this.positionBuffer=this.device.createBuffer({label:"Distance field quad positions",size:e.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.positionBuffer.getMappedRange()).set(e),this.positionBuffer.unmap();const t=new Float32Array([0,0,1,0,0,1,1,1]);this.uvBuffer=this.device.createBuffer({label:"Distance field quad UVs",size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.uvBuffer.getMappedRange()).set(t),this.uvBuffer.unmap();const i=new Uint16Array([0,1,2,2,1,3]);this.indexBuffer=this.device.createBuffer({label:"Distance field quad indices",size:i.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint16Array(this.indexBuffer.getMappedRange()).set(i),this.indexBuffer.unmap();const r=new Uint32Array(this.numberOfCells*2);let s=0;for(let o=0;o<this.gridSize;o++)for(let n=0;n<this.gridSize;n++)r[s++]=n,r[s++]=o;this.instanceBuffer=this.device.createBuffer({label:"Distance field instance data",size:r.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Uint32Array(this.instanceBuffer.getMappedRange()).set(r),this.instanceBuffer.unmap()}createUniformBuffer(){const e=new Float32Array([this.gridSize,this.gridSize,50,0]);this.uniformBuffer=this.device.createBuffer({label:"Distance field uniform buffer",size:e.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.uniformBuffer.getMappedRange()).set(e),this.uniformBuffer.unmap()}async setDistanceBuffer(e){await this.initPromise,this.distanceDataBuffer=e,this.createBindGroup()}createBindGroup(){!this.distanceDataBuffer||!this.pipeline||(this.bindGroup=this.device.createBindGroup({label:"Distance Field Bind Group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.distanceDataBuffer}}]}))}updateMaxDistance(e){const t=new Float32Array([this.gridSize,this.gridSize,e,0]);this.device.queue.writeBuffer(this.uniformBuffer,0,t)}async render(){if(await this.initPromise,!this.bindGroup)return;const e={label:"Distance Field Render Pass",colorAttachments:[{view:this.context.getCurrentTexture().createView(),clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},t=this.device.createCommandEncoder({label:"Distance Field Encoder"}),i=t.beginRenderPass(e);i.setPipeline(this.pipeline),i.setBindGroup(0,this.bindGroup),i.setVertexBuffer(0,this.positionBuffer),i.setVertexBuffer(1,this.uvBuffer),i.setVertexBuffer(2,this.instanceBuffer),i.setIndexBuffer(this.indexBuffer,"uint16"),i.drawIndexed(6,this.numberOfCells,0,0,0),i.end(),this.device.queue.submit([t.finish()])}}class D{constructor(e,t,i=32){this.device=e,this.canvas=t,this.context=t.getContext("webgpu"),this.gridSize=i,this.numberOfCells=i*i;const r=navigator.gpu.getPreferredCanvasFormat();this.context.configure({device:this.device,format:r}),this.presentationFormat=r,this.pipeline=null,this.bindGroup=null,this.arrowVertexBuffer=null,this.instanceBuffer=null,this.uniformBuffer=null,this.flowfieldDataBuffer=null,this.initPromise=this.initialize()}async initialize(){await this.createShaderPipeline(),this.createArrowBuffers(),this.createUniformBuffer(),console.log("FlowfieldRenderer initialized")}async createShaderPipeline(){const t=(await h()).flowfield;if(!t)throw new Error("Failed to load flowfield shader");const i=this.device.createShaderModule({label:"Flowfield Shader",code:t});this.pipeline=this.device.createRenderPipeline({label:"Flowfield Pipeline",layout:"auto",vertex:{module:i,entryPoint:"vs",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]},{arrayStride:8,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"uint32"},{shaderLocation:2,offset:4,format:"uint32"}]}]},fragment:{module:i,entryPoint:"fs",targets:[{format:this.presentationFormat,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}createArrowBuffers(){const e=new Float32Array([-.25,-.05,.15,-.05,.15,.05,-.25,.05,.15,-.15,.35,0,.15,.15]),t=new Uint16Array([0,1,2,2,3,0,4,5,6]);this.arrowVertexBuffer=this.device.createBuffer({label:"Arrow vertex buffer",size:e.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.arrowVertexBuffer.getMappedRange()).set(e),this.arrowVertexBuffer.unmap();const i=Math.ceil(t.byteLength/4)*4;this.arrowIndexBuffer=this.device.createBuffer({label:"Arrow index buffer",size:i,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint16Array(this.arrowIndexBuffer.getMappedRange()).set(t),this.arrowIndexBuffer.unmap();const s=new Uint32Array(this.numberOfCells*2);let o=0;for(let n=0;n<this.gridSize;n++)for(let l=0;l<this.gridSize;l++)s[o++]=l,s[o++]=n;this.instanceBuffer=this.device.createBuffer({label:"Flowfield instance data",size:s.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Uint32Array(this.instanceBuffer.getMappedRange()).set(s),this.instanceBuffer.unmap()}createUniformBuffer(){const e=new Float32Array([this.gridSize,this.gridSize,1.5,0]);this.uniformBuffer=this.device.createBuffer({label:"Flowfield uniform buffer",size:e.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.uniformBuffer.getMappedRange()).set(e),this.uniformBuffer.unmap()}async setFlowfieldBuffer(e){await this.initPromise,this.flowfieldDataBuffer=e,this.createBindGroup()}createBindGroup(){!this.flowfieldDataBuffer||!this.pipeline||(this.bindGroup=this.device.createBindGroup({label:"Flowfield Bind Group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.flowfieldDataBuffer}}]}))}async render(){if(await this.initPromise,!this.bindGroup)return;const e={label:"Flowfield Render Pass",colorAttachments:[{view:this.context.getCurrentTexture().createView(),clearValue:[.1,.1,.1,1],loadOp:"clear",storeOp:"store"}]},t=this.device.createCommandEncoder({label:"Flowfield Encoder"}),i=t.beginRenderPass(e);i.setPipeline(this.pipeline),i.setBindGroup(0,this.bindGroup),i.setVertexBuffer(0,this.arrowVertexBuffer),i.setVertexBuffer(1,this.instanceBuffer),i.setIndexBuffer(this.arrowIndexBuffer,"uint16"),i.drawIndexed(9,this.numberOfCells,0,0,0),i.end(),this.device.queue.submit([t.finish()])}}class F{constructor(e={},t=32){this.canvases=e,this.gridSize=t,this.numberOfCells=t*t,this.device=null,this.isRunning=!1,this.currentIteration=0,this.maxIterations=512,this.usesPingPong=!0,this.useRelaxation=!0,this.buffers=null,this.pipelines=null,this.bindGroups=null,this.distanceFieldHeader=null,this.flowfieldHeader=null,this.gridData=new Float32Array(this.numberOfCells).fill(1),this.goalX=Math.floor(t/2),this.goalY=Math.floor(t/2),this.simulationSpeed=100,this.maxDistanceValue=50,this.hasConverged=!1,this.lastIterationData=null,this.obstacleRenderer=null,this.distanceRenderer=null,this.flowfieldRenderer=null}async initialize(){try{return console.log("Initializing PathfindingSimulation..."),this.device=await p(),console.log("WebGPU device initialized"),this.buffers=await b(this.device,this.gridSize,this.numberOfCells),this.pipelines=await v(this.device),this.bindGroups=await G(this.device,this.buffers,this.pipelines),this.setGoal(this.goalX,this.goalY),console.log("PathfindingSimulation initialized successfully"),this.device}catch(e){throw console.error("Failed to initialize PathfindingSimulation:",e),e}}initializeHeaderElements(){this.distanceFieldHeader=document.getElementById("distanceFieldHeader"),this.flowfieldHeader=document.getElementById("flowfieldHeader")}startBlinking(){this.distanceFieldHeader&&this.distanceFieldHeader.classList.add("motion-preset-blink"),this.flowfieldHeader&&this.flowfieldHeader.classList.add("motion-preset-blink")}stopBlinking(){this.distanceFieldHeader&&this.distanceFieldHeader.classList.remove("motion-preset-blink"),this.flowfieldHeader&&this.flowfieldHeader.classList.remove("motion-preset-blink")}async initializeRenderers(){this.canvases.obstacleCanvas&&(this.obstacleRenderer=new C(this.device,this.canvases.obstacleCanvas,this.gridSize),await this.obstacleRenderer.setGridDataBuffer(this.buffers.gridBuffer),this.obstacleRenderer.setUpdateCellCallback((e,t,i)=>{this.updateCell(e,t,i),this.obstacleRenderer.render()}),this.obstacleRenderer.updateGoalPosition(this.goalX,this.goalY),await this.obstacleRenderer.render()),this.canvases.distanceCanvas&&(this.distanceRenderer=new R(this.device,this.canvases.distanceCanvas,this.gridSize),await this.distanceRenderer.setDistanceBuffer(this.buffers.distanceBufferPing),await this.distanceRenderer.render()),this.canvases.flowfieldCanvas&&(this.flowfieldRenderer=new D(this.device,this.canvases.flowfieldCanvas,this.gridSize),await this.flowfieldRenderer.setFlowfieldBuffer(this.buffers.flowfieldBuffer),await this.flowfieldRenderer.render())}setRelaxation(e){this.useRelaxation=e,console.log(`Relaxation ${e?"enabled":"disabled"}`),this.maxDistanceValue=Math.max(this.gridSize*.5,10),this.lastIterationData=null,this.hasConverged=!1,this.distanceRenderer&&this.distanceRenderer.updateMaxDistance(this.maxDistanceValue),console.log(`Max distance reset to ${this.maxDistanceValue} for ${e?"relaxation":"no-relaxation"} mode`)}async updateRenderersAndRender(){const e=this.usesPingPong?this.buffers.distanceBufferPong:this.buffers.distanceBufferPing;this.distanceRenderer&&(await this.distanceRenderer.setDistanceBuffer(e),this.distanceRenderer.updateMaxDistance(this.maxDistanceValue),await this.distanceRenderer.render()),this.flowfieldRenderer&&await this.flowfieldRenderer.render(),this.obstacleRenderer&&await this.obstacleRenderer.render()}async runSimulation(){this.isRunning&&(this.stop(),await new Promise(n=>setTimeout(n,50))),this.currentIteration=0,this.usesPingPong=!0,this.hasConverged=!1,this.lastIterationData=null;let e=0,t=0;for(let n=0;n<this.gridData.length;n++)this.gridData[n]===0?e++:this.gridData[n]===.3&&t++;const i=(e+t*.5)/this.numberOfCells,r=Math.max(this.gridSize*.5,10);this.maxDistanceValue=r*(1+i*2);const s=new Float32Array(this.numberOfCells).fill(0);s[this.goalY*this.gridSize+this.goalX]=1,this.device.queue.writeBuffer(this.buffers.distanceBufferPing,0,s),this.device.queue.writeBuffer(this.buffers.distanceBufferPong,0,s);const o=new Float32Array(this.numberOfCells*2).fill(0);this.device.queue.writeBuffer(this.buffers.flowfieldBuffer,0,o),await this.device.queue.onSubmittedWorkDone(),console.log(`Starting BFS simulation from goal (${this.goalX}, ${this.goalY})...`),this.isRunning=!0,this.startBlinking();try{for(let n=0;n<this.maxIterations&&this.isRunning&&!this.hasConverged;n++){if(await this.runBFSIteration(),await this.generateFlowfield(),await this.updateRenderersAndRender(),n%3===0&&(await this.checkConvergence(),await this.updateMaxDistance()),this.hasConverged){console.log(`BFS converged after ${this.currentIteration} iterations`);break}this.simulationSpeed>0&&await new Promise(l=>setTimeout(l,this.simulationSpeed))}this.hasConverged||console.log(`BFS completed after ${this.currentIteration} iterations (max reached)`)}catch(n){console.error("Simulation error:",n)}finally{this.isRunning=!1,this.stopBlinking()}}async runBFSIteration(){const e=this.device.createCommandEncoder(),t=e.beginComputePass(),i=this.useRelaxation?"bfs":"bfsNoRelaxation",r=this.pipelines[i].pipeline,s=this.usesPingPong?this.bindGroups.bfsPing:this.bindGroups.bfsPong;t.setPipeline(r),t.setBindGroup(0,s);const o=Math.ceil(this.gridSize/8),n=Math.ceil(this.gridSize/8);t.dispatchWorkgroups(o,n),t.end(),this.device.queue.submit([e.finish()]),await this.device.queue.onSubmittedWorkDone(),this.usesPingPong=!this.usesPingPong,this.currentIteration++}async generateFlowfield(){const e=this.device.createCommandEncoder(),t=e.beginComputePass();t.setPipeline(this.pipelines.gradient.pipeline);const i=this.bindGroups.getGradientBindGroup(this.usesPingPong);t.setBindGroup(0,i);const r=Math.ceil(this.gridSize/8),s=Math.ceil(this.gridSize/8);t.dispatchWorkgroups(r,s),t.end(),this.device.queue.submit([e.finish()]),await this.device.queue.onSubmittedWorkDone()}async checkConvergence(){if(!this.buffers)return;const e=this.usesPingPong?this.buffers.distanceBufferPong:this.buffers.distanceBufferPing,t=this.device.createBuffer({size:this.numberOfCells*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),i=this.device.createCommandEncoder();i.copyBufferToBuffer(e,0,t,0,this.numberOfCells*4),this.device.queue.submit([i.finish()]),await t.mapAsync(GPUMapMode.READ);const r=new Float32Array(t.getMappedRange()),s=new Float32Array(r);if(t.unmap(),t.destroy(),this.lastIterationData){let o=!1;const n=1e-6;for(let l=0;l<this.numberOfCells;l++)if(Math.abs(s[l]-this.lastIterationData[l])>n){o=!0;break}o||(this.hasConverged=!0,console.log("Distance field converged - no changes detected"))}this.lastIterationData=s}async updateMaxDistance(){const e=await this.getCurrentDistanceData();if(e){let t=0,i=0,r=0;for(let s=0;s<e.length;s++)e[s]>0&&(i++,r+=e[s],e[s]>t&&(t=e[s]));if(i>10&&(r/=i,t<this.maxDistanceValue*.4?this.maxDistanceValue=Math.max(t*1.4,5):t<this.maxDistanceValue*.7?this.maxDistanceValue=Math.max(t*1.2,8):t>this.maxDistanceValue*.9&&(this.maxDistanceValue=t*1.15),r>0&&t/r>10)){const s=r*3;s<this.maxDistanceValue*.8&&(this.maxDistanceValue=Math.max(s,10))}}}async getCurrentDistanceData(){if(!this.buffers)return null;const e=this.usesPingPong?this.buffers.distanceBufferPong:this.buffers.distanceBufferPing,t=this.device.createBuffer({size:this.numberOfCells*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),i=this.device.createCommandEncoder();i.copyBufferToBuffer(e,0,t,0,this.numberOfCells*4),this.device.queue.submit([i.finish()]),await t.mapAsync(GPUMapMode.READ);const r=new Float32Array(t.getMappedRange()),s=new Float32Array(r);return t.unmap(),t.destroy(),s}updateCell(e,t,i){const r=t*this.gridSize+e;if(i===3){this.setGoal(e,t);return}this.gridData[r]=i,this.hasConverged=!1,this.lastIterationData=null,this.resetDistanceField(),this.device.queue.writeBuffer(this.buffers.gridBuffer,0,this.gridData)}resetDistanceField(){const e=new Float32Array(this.numberOfCells).fill(0);if(e[this.goalY*this.gridSize+this.goalX]=1,this.buffers&&(this.device.queue.writeBuffer(this.buffers.distanceBufferPing,0,e),this.device.queue.writeBuffer(this.buffers.distanceBufferPong,0,e)),this.currentIteration=0,this.usesPingPong=!0,this.maxDistanceValue=Math.max(this.gridSize*.6,12),this.buffers){const t=new Float32Array(this.numberOfCells*2).fill(0);this.device.queue.writeBuffer(this.buffers.flowfieldBuffer,0,t)}this.distanceRenderer&&(this.distanceRenderer.setDistanceBuffer(this.buffers.distanceBufferPing),this.distanceRenderer.updateMaxDistance(this.maxDistanceValue))}setGoal(e,t){this.goalX=e,this.goalY=t,this.hasConverged=!1,this.lastIterationData=null;const i=new Float32Array(this.numberOfCells).fill(0);i[t*this.gridSize+e]=1,this.device.queue.writeBuffer(this.buffers.distanceBufferPing,0,i),this.device.queue.writeBuffer(this.buffers.distanceBufferPong,0,i),this.currentIteration=0,this.usesPingPong=!0}stop(){this.isRunning=!1,this.stopBlinking()}resetGrid(){console.log("Resetting grid to default state..."),this.stop(),this.gridData.fill(1),this.buffers&&this.device.queue.writeBuffer(this.buffers.gridBuffer,0,this.gridData);const e=Math.floor(this.gridSize/2),t=Math.floor(this.gridSize/2);if(this.setGoal(e,t),this.maxDistanceValue=10,this.distanceRenderer&&this.distanceRenderer.updateMaxDistance(this.maxDistanceValue),this.obstacleRenderer&&(this.obstacleRenderer.updateGoalPosition(e,t),this.obstacleRenderer.currentSourcePos={x:e,y:t}),this.flowfieldRenderer){const i=new Float32Array(this.numberOfCells*2).fill(0);this.device.queue.writeBuffer(this.buffers.flowfieldBuffer,0,i)}this.renderAllCanvases(),console.log("Grid reset complete")}async renderAllCanvases(){try{this.obstacleRenderer&&await this.obstacleRenderer.render(),this.distanceRenderer&&await this.distanceRenderer.render(),this.flowfieldRenderer&&await this.flowfieldRenderer.render()}catch(e){console.error("Error rendering canvases:",e)}}async loadMaze(){try{console.log("Loading maze from maze.csv..."),await this.loadObstacleGridFromCSV("./maze.csv");let e=Math.floor(this.gridSize/2),t=Math.floor(this.gridSize/2),i=!1;for(let r=0;r<this.gridSize/2&&!i;r++)for(let s=-r;s<=r&&!i;s++)for(let o=-r;o<=r&&!i;o++){const n=Math.floor(this.gridSize/2)+o,l=Math.floor(this.gridSize/2)+s;if(n>=0&&n<this.gridSize&&l>=0&&l<this.gridSize){const f=l*this.gridSize+n;this.gridData[f]===1&&(e=n,t=l,i=!0)}}this.setGoal(e,t),this.obstacleRenderer&&(this.obstacleRenderer.updateGoalPosition(e,t),this.obstacleRenderer.currentSourcePos={x:e,y:t},this.obstacleRenderer.render()),this.renderAllCanvases(),console.log(`Maze loaded successfully! Goal set at (${e}, ${t})`)}catch(e){console.error("Failed to load maze:",e),console.log("Creating fallback maze pattern..."),this.createFallbackMaze()}}createFallbackMaze(){this.gridData.fill(1);for(let i=0;i<this.gridSize;i++)for(let r=0;r<this.gridSize;r++){const s=i*this.gridSize+r;r===0||r===this.gridSize-1||i===0||i===this.gridSize-1?this.gridData[s]=0:r%4===0&&i%2===0||i%4===0&&r%2===0?this.gridData[s]=0:(r+i)%7===0&&(this.gridData[s]=.3)}const e=Math.floor(this.gridSize/2),t=Math.floor(this.gridSize/2);this.gridData[t*this.gridSize+e]=1,this.buffers&&this.device.queue.writeBuffer(this.buffers.gridBuffer,0,this.gridData),this.setGoal(e,t),this.obstacleRenderer&&(this.obstacleRenderer.updateGoalPosition(e,t),this.obstacleRenderer.currentSourcePos={x:e,y:t},this.obstacleRenderer.render()),this.renderAllCanvases(),console.log("Fallback maze created")}async loadObstacleGridFromCSV(e){try{return console.log(`Loading obstacle grid from: ${e}`),this.gridData=await x(e),this.buffers&&this.device.queue.writeBuffer(this.buffers.gridBuffer,0,this.gridData),console.log("Obstacle grid loaded successfully"),this.gridData}catch(t){throw console.error("Failed to load obstacle grid:",t),t}}setSimulationSpeed(e){this.simulationSpeed=Math.max(10,Math.min(1e3,e))}}document.addEventListener("DOMContentLoaded",async()=>{try{const a=new F({},32),e=await a.initialize();console.log("Simulation initialized successfully.");const t=document.getElementById("obstacleCanvas"),i=document.getElementById("distanceCanvas"),r=document.getElementById("flowfieldCanvas");a.canvases={obstacleCanvas:t,distanceCanvas:i,flowfieldCanvas:r},await a.initializeRenderers(),a.initializeHeaderElements(),a.obstacleRenderer&&await a.obstacleRenderer.render(),a.distanceRenderer&&await a.distanceRenderer.render(),a.flowfieldRenderer&&await a.flowfieldRenderer.render(),console.log("Renderers initialized successfully."),U(a),window.simulation=a}catch(a){console.error("Error in main setup:",a)}});function U(a){const e=document.getElementById("startBtn");e&&e.addEventListener("click",async()=>{a.isRunning?console.log("Restarting BFS simulation..."):console.log("Starting BFS simulation..."),await a.runSimulation()});const t=document.getElementById("resetBtn");t&&t.addEventListener("click",()=>{console.log("Resetting entire grid (obstacles + goal)..."),a.resetGrid()});const i=document.getElementById("mazeBtn");i&&i.addEventListener("click",async()=>{console.log("Loading maze..."),await a.loadMaze()});const r=document.getElementById("relaxationToggle");r&&(r.checked=!0,r.addEventListener("change",o=>{const n=o.target.checked;a.setRelaxation(n),console.log(`Relaxation ${n?"enabled":"disabled"}`);const l=document.getElementById("relaxationText");l&&(n?l.className="text-goldenrod-300":l.className="text-neutral")}));const s=document.getElementById("speedRange");if(s){s.min=1,s.max=50,s.value=10,s.addEventListener("input",l=>{const f=parseInt(l.target.value),d=Math.max(10,Math.round(510-f*10));a.setSimulationSpeed(d),console.log(`Speed set to ${f} (${d}ms delay)`)});const n=Math.max(10,Math.round(510-10*10));a.setSimulationSpeed(n)}}
